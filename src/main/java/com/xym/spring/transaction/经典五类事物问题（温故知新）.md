# 数据并发问题
3 类数据读问题  

2 类数据更新问题


> 引用自Spring.3.x企业应用开发实战 308页

------

## 1、脏读（dirty read）
A事务读取B事务尚未提交的更改数据，并在这个数据的基础上操作。如果恰巧B事务回滚，那么A事务读取到的数据根本是不被承认的，来看取款事务和转账事务并发时引发的脏读场景：

时间 |转账事务A|取款事务B
---|---|---
T1 ||开始事务
T2 |开始事务|
T3 ||查询账户余额1000
T4||取出500元把余额改成500
T5|查询账户余额为500（脏读）|
T6||撤销事务余额恢复为1000
T7|汇入100元，把余额改为600|
T8|提交事务|

说明：在这个场景中，B希望取款500元而后又撤销了动作，而A往相同的账户中转账100元，就因为A事务读取了B事务尚未提交的数据，因而造成账户白白丢失了500元。

## 2、不可重复读（unrepeatable read）
不可重复读是指A事务读取了B事务已经提交的更改数据。假设A在取款事务的过程中，B往该账户转账100元，A二次读取账户的余额发生不一致：

时间 | 取款事务A|转账事务B
---|---|---
T1||开始事务
T2|开始事务|
T3||查询账户余额为1000
T4|查询账户余额为1000|
T5||取出100元把余额改为900元
T6||提交事务
T7|查询账户余额为900元（和T4读取不一致）|

说明：在同一事务A中，在时间点T4和T7读取账户余额存款不一样

## 3、幻象读（phantom read）
A事务读取B事务提交的新增数据，这时A事务将出现幻象读问题。幻象读一般发生在计算统计数据的事务中。举个例子，假设银行系统在同一个事务中，二次统计存款账户总金额，在二次统计过程中，刚好新增一个存款账户，并存入100元，这时两次统计的总金额将不一致：

时间|统计金额事务A|转账事务B
---|---|---
T1||开始事务
T2|开始事务|
T3|统计总存款数为10000|
T4||新增一个存款账户，存款100元
T5||提交事务
T6|再次统计总存款数为10100（幻象读）|

说明：如果新增数据刚好满足事务的查询条件，这个数据就进入了事务的视野，因而产生二个统计不一致的情况。  
幻象读和不可重复读是二个容易混淆的概念。前者是指读到了其他已经提交事务的新增数据，而后者是指读到了已经提交事务的更改数据（修改或删除），为了避免这二种情况，采取的对策是不同的，防止读取到更改的数据，只需要对操作的数据添加行级锁，阻止操作中数据发生变化，而防止读取到新增数据，则往往需要添加表级锁----将整个表锁定，防止新增数据。

------

## 第一类丢失更新  
A事务撤销时，把已经提交的B事务的更新数据覆盖了。这种错误可能造成严重的问题，通过下面取款转账的示例就可以看出来：


时间|取款事务A|转账事务B
---|---|---
T1|开始事务|
T2||开始事务
T3|查询账户余额为1000元|
T4||查询账户余额为1000元
T5||汇入100元，把账户余额改为1100元
T6||提交事务
T7|取出100元，把余额改为900元|
T8|撤销事务|
T9|余额恢复1000元（丢失更新）|

说明：A事务在撤销时，“不小心”将B事务已经转入的金额给抹去了。


## 第二类丢失更新
A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失：

时间 |转账事务A|取款事务B
---|---|---
T1||开始事务
T2|开始事务|
T3||查询账户余额为1000
T4|查询账户余额为1000|
T5||取出100元，把账户改成900元
T6||提交事务
T7|汇入100元|
T8|提交事务|
T9|把余额改为1100元（丢失更新）|

说明：由于转账事务覆盖了取款事务对存款账户所做的更新，导致银行最后损失了100元，相反如果转账事务先提交，那么用户账户将损失100元。


